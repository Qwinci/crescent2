#include "stdio.hpp"
#include "arch/cpu.hpp"
#include "fs/tmpfs.hpp"
#include "fs/tar.hpp"
#include "exe/pe.hpp"
#include "assert.hpp"
#include "sched/semaphore.hpp"

// FILE_AUTOGENERATED_DEVICE_NAME == \Device\%08x

#include "exe/driver_loader.hpp"
#include "fs/registry.hpp"
#include "misc/callback.hpp"
#include "sched/ps.hpp"

void pci_irq_init(LoadedPe* pci_sys_pe);
void pnp_init();
void event_init();

[[noreturn]] void kmain(const void* initrd) {
	println("[kernel]: entered kmain");
	init_driver_loader();
	registry_init();
	callback_init();
	pnp_init();
	event_init();

	auto vfs = tmpfs_create();
	init_vfs_from_tar(*vfs, initrd);
	ROOT_VFS = std::move(vfs);

	auto acpi_dev = load_predefined_acpi_driver(u"acpi driver", u"drivers/uacpi.sys");

	println("loading pci.sys");
	auto [pci_pe, pci_sys_dev] = load_predefined_bus_driver(u"pci driver", u"drivers/pci.sys");
	pci_irq_init(&pci_pe);
	auto* process = create_process(u"init");

	auto ntdll_file = vfs_lookup(nullptr, u"libs/ntdll.dll");
	assert(ntdll_file);
	auto ntdll_res = pe_load(process, ntdll_file, true);
	assert(ntdll_res);
	ntdll_file = nullptr;
	// the thread's process has to be changed temporarily to make sure the page map is kept even if
	// the thread is preempted
	get_current_thread()->process = process;
	process->page_map.use();
	fill_ntdll_offsets(ntdll_res->base);
	get_current_thread()->process = &*KERNEL_PROCESS;
	KERNEL_MAP->use();

	process->ntdll_base = ntdll_res->base;

	auto exe_file = vfs_lookup(nullptr, u"apps/hello_world.exe");
	assert(exe_file);
	auto exe_res = pe_load(process, exe_file, true);
	assert(exe_res);
	exe_file = nullptr;

	auto cpu = get_current_cpu();
	auto* thread = new Thread {
		u"user thread",
		cpu,
		process,
		true,
		reinterpret_cast<void (*)(void*)>(exe_res->entry),
		nullptr};

	cpu->scheduler.queue(cpu, thread);

	cpu->scheduler.block();
	panic("[kernel]: returned to kmain");
}
